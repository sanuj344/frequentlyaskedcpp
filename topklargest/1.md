# Find Top K Largest Elements in an Array (C++)

## Problem

Given an array of integers and an integer `k`,  
return the `k` largest elements from the array.

The result can be returned in any order unless specified otherwise.

---

## Example


Input:
arr = {3, 2, 1, 5, 6, 4}
k = 2

Output:
{6, 5}


---

---

# Approach 1 — Sorting (Brute Force)

## Idea

1. Sort the array in descending order.
2. Return the first `k` elements.

---

## Pseudocode


sort array in descending order
return first k elements


---

## Complexity

- Time: O(n log n)
- Space: O(1)

---

## Limitation

Sorting the entire array is unnecessary when we only need `k` elements.

---

---

# Approach 2 — Min Heap (Optimal)

## Key Idea

Maintain a **Min Heap of size k**.

- Push elements one by one.
- If heap size becomes greater than k:
  remove the smallest element.
- At the end, heap contains the k largest elements.

---

## Why Min Heap?

Because:
- Smallest element stays at the top.
- If a larger element appears, we remove the smallest.
- Heap always maintains only the largest `k` elements.

---

## Pseudocode


create empty minHeap

for each element in array:
push element into heap

if heap size > k:
    remove smallest element

return all elements from heap


---

## Complexity

- Time: O(n log k)
- Space: O(k)

---

## Why This Is Better

When `k` is small compared to `n`:

O(n log k) << O(n log n)

So this is more efficient than sorting.

---

---

# Edge Cases

- k = 1
- k = n
- k > n (invalid case handling required)
- Duplicate elements
- Negative numbers

---

---

# Interview Tip

If interviewer asks:

“Can you do better than sorting?”

Answer:

“Yes, by maintaining a min heap of size k to track only the largest k elements.”

---

---

# Related Problems

- Kth Largest Element
- Top K Frequent Elements
- Median of Data Stream
- Quickselect Algorithm
